# PRD: REQ/REP Protocol Engine (Phase 1)

**Issue**: sp-ms6.2
**Status**: Draft
**Author**: Claude
**Date**: 2026-01-27

## Overview

The REQ/REP protocol implements synchronous request-reply messaging. A REQ (requester) socket sends a message and blocks until a REP (replier) socket responds. This is the first protocol pattern implemented in SP, establishing patterns for all subsequent protocols.

The protocol guarantees message correlation via request IDs and supports automatic request retry for reliability.

## Requirements

### Functional Requirements

| ID | Requirement |
|----|-------------|
| RR-1 | REQ socket sends requests and receives correlated replies |
| RR-2 | REP socket receives requests and sends replies to the requester |
| RR-3 | Request IDs correlate requests with replies (32-bit, MSB set) |
| RR-4 | REQ socket automatically resends requests on configurable timeout |
| RR-5 | REQ socket cancels pending request when new request is sent |
| RR-6 | REP socket stores backtrace header for reply routing |
| RR-7 | Both sockets enforce state machine (send/recv ordering) |
| RR-8 | Multiple peers supported with load balancing (REQ) |

### Non-Functional Requirements

| ID | Requirement |
|----|-------------|
| NF-1 | Request-reply latency: < 20μs (local Unix transport) |
| NF-2 | Zero-copy message path where possible |
| NF-3 | State machine checks: O(1) |
| NF-4 | Thread safety: all socket operations goroutine-safe |
| NF-5 | Clean shutdown: no goroutine leaks, pending operations canceled |

## Design

### Protocol State Machines

**REQ Socket States**:

```
                ┌──────┐
                │ IDLE │
                └──┬───┘
                   │ Send()
                   ▼
          ┌─────────────────┐
          │ REQUEST_SENT    │◄──────┐
          └───────┬─────────┘       │
                  │                 │ resend timer
         Recv() ──┤                 │
                  │                 │
                  ▼                 │
          ┌─────────────────┐       │
          │ AWAITING_REPLY  │───────┘
          └───────┬─────────┘
                  │ reply received
                  ▼
                ┌──────┐
                │ IDLE │
                └──────┘
```

- `Send()` in IDLE: starts request, arms resend timer
- `Recv()` in IDLE: returns `ErrInvalidState`
- `Send()` while awaiting: cancels pending, starts new request
- Reply received: matches request ID, returns to IDLE

**REP Socket States**:

```
                ┌──────┐
                │ IDLE │
                └──┬───┘
                   │ Recv() (request arrives)
                   ▼
          ┌─────────────────┐
          │ REQUEST_RECEIVED│
          └───────┬─────────┘
                  │ Send() (reply)
                  ▼
                ┌──────┐
                │ IDLE │
                └──────┘
```

- `Recv()` in IDLE: blocks until request arrives
- `Send()` in IDLE: returns `ErrInvalidState`
- `Send()` after `Recv()`: sends reply using stored backtrace
- Multiple requests queued while processing previous

### Message Header Format

The protocol uses a backtrace header for request-reply correlation:

```
┌────────────────┬────────────────┬────────────────┐
│  Peer ID (opt) │  Peer ID (opt) │   Request ID   │
│  MSB=0         │  MSB=0         │   MSB=1        │
│  4 bytes BE    │  4 bytes BE    │   4 bytes BE   │
└────────────────┴────────────────┴────────────────┘
```

- **Request ID**: Generated by REQ socket (0x80000000 - 0xFFFFFFFF)
- **Peer IDs**: For future forwarding devices (0x00000000 - 0x7FFFFFFF)
- **Big-endian**: Network byte order for all IDs

```go
// Header parsing/building
const (
    RequestIDMask = 0x80000000  // MSB set indicates request ID
    HeaderSize    = 4           // Bytes per ID in header
)

// EncodeRequestID creates a 4-byte request ID with MSB set.
func EncodeRequestID(id uint32) [4]byte

// DecodeRequestID extracts the request ID from header.
func DecodeRequestID(header []byte) (uint32, error)

// IsRequestID returns true if the ID has MSB set.
func IsRequestID(id uint32) bool
```

### REQ Socket Implementation

```go
// ReqSocket implements the REQ (requester) protocol.
type ReqSocket struct {
    // Base socket functionality
    base     *BaseSocket

    // Protocol state
    state    atomic.Uint32   // ReqState enum
    mu       sync.Mutex      // Protects state transitions

    // Current request tracking
    reqID    atomic.Uint32   // Current request ID counter
    pending  *pendingRequest // Current pending request

    // Peer management
    peers    *PeerRegistry
    peerIdx  atomic.Uint32   // Round-robin index for load balancing

    // Configuration
    resendTime time.Duration // Auto-resend interval (0 = disabled)

    // Channels
    recvCh   <-chan *Message // From I/O workers
    sendCh   chan<- *Message // To I/O workers
}

// ReqState represents REQ socket state.
type ReqState uint32

const (
    ReqStateIdle ReqState = iota
    ReqStateRequestSent
    ReqStateAwaitingReply
)

// pendingRequest tracks an outstanding request.
type pendingRequest struct {
    id       uint32
    msg      *Message
    peer     PeerID
    sentAt   time.Time
    replyCh  chan *Message   // Delivers reply to blocked Recv()
    cancel   context.CancelFunc
}

// NewReqSocket creates a REQ socket.
func NewReqSocket(cfg SocketConfig) (*ReqSocket, error)

// Send sends a request message.
// Blocks until the message is queued for transmission.
// Returns ErrClosed if socket is closed.
func (s *ReqSocket) Send(data []byte) error

// Recv waits for a reply to the last sent request.
// Blocks until a reply is received or the request times out.
// Returns ErrInvalidState if no request is pending.
// Returns ErrTimeout if the reply doesn't arrive in time.
func (s *ReqSocket) Recv() ([]byte, error)

// SendRecv sends a request and waits for the reply.
// Convenience method combining Send and Recv.
func (s *ReqSocket) SendRecv(data []byte) ([]byte, error)

// Close closes the socket and releases resources.
func (s *ReqSocket) Close() error

// SetResendTime sets the automatic resend interval.
// Set to 0 to disable automatic resends.
func (s *ReqSocket) SetResendTime(d time.Duration)
```

**REQ Protocol Goroutine**:

```go
func (s *ReqSocket) run(ctx context.Context) {
    defer s.cleanup()

    var resendTimer *time.Timer

    for {
        select {
        case <-ctx.Done():
            return

        case msg := <-s.recvCh:
            // Check if this is a reply to our pending request
            if s.pending != nil {
                reqID, err := DecodeRequestID(msg.Header)
                if err == nil && reqID == s.pending.id {
                    // Deliver reply
                    s.pending.replyCh <- msg
                    s.pending = nil
                    s.state.Store(uint32(ReqStateIdle))
                    if resendTimer != nil {
                        resendTimer.Stop()
                    }
                }
            }

        case <-resendTimer.C:
            // Resend pending request if still awaiting
            if s.pending != nil && s.state.Load() == uint32(ReqStateAwaitingReply) {
                s.resendPending()
                resendTimer.Reset(s.resendTime)
            }
        }
    }
}
```

### REP Socket Implementation

```go
// RepSocket implements the REP (replier) protocol.
type RepSocket struct {
    // Base socket functionality
    base     *BaseSocket

    // Protocol state
    state    atomic.Uint32   // RepState enum
    mu       sync.Mutex      // Protects state transitions

    // Current request tracking
    currentBacktrace []byte  // Stored for reply routing
    currentPeer      PeerID  // Source of current request

    // Request queue
    requestQueue chan *Message  // Buffered queue of incoming requests

    // Channels
    recvCh   <-chan *Message // From I/O workers
    sendCh   chan<- *Message // To I/O workers
}

// RepState represents REP socket state.
type RepState uint32

const (
    RepStateIdle RepState = iota
    RepStateRequestReceived
)

// NewRepSocket creates a REP socket.
func NewRepSocket(cfg SocketConfig) (*RepSocket, error)

// Recv waits for an incoming request.
// Blocks until a request arrives.
// Returns ErrClosed if socket is closed.
func (s *RepSocket) Recv() ([]byte, error)

// Send sends a reply to the last received request.
// Returns ErrInvalidState if no request is pending.
func (s *RepSocket) Send(data []byte) error

// Close closes the socket and releases resources.
func (s *RepSocket) Close() error
```

**REP Protocol Goroutine**:

```go
func (s *RepSocket) run(ctx context.Context) {
    defer s.cleanup()

    for {
        select {
        case <-ctx.Done():
            return

        case msg := <-s.recvCh:
            // Queue incoming request
            select {
            case s.requestQueue <- msg:
                // Queued successfully
            default:
                // Queue full, drop message (backpressure)
                msg.Release()
            }
        }
    }
}

// Recv implementation
func (s *RepSocket) Recv() ([]byte, error) {
    select {
    case msg := <-s.requestQueue:
        // Store backtrace for reply
        s.mu.Lock()
        s.currentBacktrace = msg.Header
        s.currentPeer = msg.PeerID
        s.state.Store(uint32(RepStateRequestReceived))
        s.mu.Unlock()

        data := make([]byte, len(msg.Data))
        copy(data, msg.Data)
        msg.Release()
        return data, nil

    case <-s.base.ctx.Done():
        return nil, ErrClosed
    }
}

// Send implementation
func (s *RepSocket) Send(data []byte) error {
    s.mu.Lock()
    if s.state.Load() != uint32(RepStateRequestReceived) {
        s.mu.Unlock()
        return ErrInvalidState
    }
    backtrace := s.currentBacktrace
    peer := s.currentPeer
    s.currentBacktrace = nil
    s.state.Store(uint32(RepStateIdle))
    s.mu.Unlock()

    msg := s.base.pool.NewMessage(data)
    msg.Header = backtrace
    msg.PeerID = peer

    select {
    case s.sendCh <- msg:
        return nil
    case <-s.base.ctx.Done():
        msg.Release()
        return ErrClosed
    }
}
```

### Load Balancing (REQ)

When a REQ socket has multiple peers, requests are distributed round-robin:

```go
func (s *ReqSocket) selectPeer() (PeerID, error) {
    peers := s.peers.All()
    if len(peers) == 0 {
        return 0, ErrNoPeers
    }

    // Round-robin selection
    idx := s.peerIdx.Add(1) % uint32(len(peers))
    return peers[idx].ID, nil
}
```

### Error Types

```go
var (
    // ErrInvalidState indicates operation not allowed in current state.
    ErrInvalidState = errors.New("protocol: invalid state")

    // ErrNoPeers indicates no connected peers available.
    ErrNoPeers = errors.New("protocol: no peers")

    // ErrTimeout indicates the operation timed out.
    ErrTimeout = errors.New("protocol: timeout")

    // ErrClosed indicates the socket has been closed.
    ErrClosed = errors.New("protocol: closed")

    // ErrRequestCanceled indicates the request was canceled by a new request.
    ErrRequestCanceled = errors.New("protocol: request canceled")
)
```

### Configuration

```go
// ReqConfig holds REQ socket configuration.
type ReqConfig struct {
    // ResendTime is the automatic resend interval.
    // Default: 60s. Set to 0 to disable.
    ResendTime time.Duration

    // RecvTimeout is the maximum time to wait for a reply.
    // Default: 0 (no timeout).
    RecvTimeout time.Duration

    // SendTimeout is the maximum time to wait for send to complete.
    // Default: 0 (no timeout).
    SendTimeout time.Duration
}

// RepConfig holds REP socket configuration.
type RepConfig struct {
    // RequestQueueSize is the buffer size for incoming requests.
    // Default: 16.
    RequestQueueSize int

    // SendTimeout is the maximum time to wait for send to complete.
    // Default: 0 (no timeout).
    SendTimeout time.Duration
}
```

### Integration with I/O Workers

```
┌─────────────────────────────────────────────────────────────────┐
│                       ReqSocket                                  │
│  ┌────────────────────────────────────────────────────────────┐│
│  │                Protocol Goroutine                          ││
│  │  - State machine management                                ││
│  │  - Request tracking                                        ││
│  │  - Resend timer                                            ││
│  │  - Reply correlation                                       ││
│  └────────────────────────────────────────────────────────────┘│
│        │ sendCh                              ▲ recvCh          │
│        ▼                                      │                 │
│  ┌─────────────────────────────────────────────────────────────┤
│  │                   WorkerPair                                ││
│  │        (from I/O Workers layer)                             ││
│  └─────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────┘
```

## Testing Strategy

### Unit Tests

| Test | Description |
|------|-------------|
| `TestReqStateMachine` | State transitions enforced correctly |
| `TestRepStateMachine` | State transitions enforced correctly |
| `TestReqSendRecv` | Basic request-reply flow |
| `TestReqAutoResend` | Automatic resend on timeout |
| `TestReqCancelPending` | New request cancels pending |
| `TestReqMultiplePeers` | Round-robin load balancing |
| `TestRepBacktrace` | Backtrace stored and used for reply |
| `TestReqRecvTimeout` | Timeout handling |
| `TestInvalidStateErrors` | Correct errors for wrong state |
| `TestSocketClose` | Clean shutdown, pending ops canceled |

### Integration Tests

| Test | Description |
|------|-------------|
| `TestReqRepBasic` | Full request-reply with transport |
| `TestReqRepMultipleExchanges` | Sequential request-reply pairs |
| `TestReqRepConcurrent` | Multiple REQ sockets to one REP |
| `TestReqRepUnixTransport` | REQ/REP over Unix sockets |
| `TestReqRepIPTransport` | REQ/REP over IP sockets |

### Benchmarks

| Benchmark | Target |
|-----------|--------|
| `BenchmarkReqRepLatency` | < 20μs round-trip (Unix) |
| `BenchmarkReqRepThroughput` | > 50K req/sec |
| `BenchmarkReqStateMachine` | < 100ns per transition |

## Acceptance Criteria

1. **REQ Socket Implemented**: Send, Recv, state machine, resend timer
2. **REP Socket Implemented**: Recv, Send, backtrace handling
3. **State Machines Enforced**: Invalid operations return ErrInvalidState
4. **Request Correlation**: Request IDs correctly match requests to replies
5. **Auto-Resend Works**: Requests automatically resent on timeout
6. **Load Balancing Works**: Requests distributed across peers
7. **Clean Shutdown**: No goroutine leaks, pending operations canceled
8. **Benchmarks Pass**: Meet latency and throughput targets
9. **Documentation**: GoDoc comments on all exported types/methods

## Dependencies

- Transport Abstraction Layer (sp-ms6.1) - Transport interface
- Shared Infrastructure (sp-ms6.7) - BufferPool, PeerRegistry, Message
- I/O Workers (sp-ms6.3) - WorkerPair

## References

- [NNG REQ/REP Documentation](https://nng.nanomsg.org/man/tip/nng_req.7.html)
- SP ARCHITECTURE.md - Protocol Engine section
- BACKGROUND/nng/nng-request-reply.md - NNG reference
